# 多租户权限控制与数据隔离架构设计指南

> **状态**: 需求已记录，暂缓开发  
> **优先级**: 低  
> **预计开发周期**: 8-12周  
> **前置条件**: 现有单租户系统稳定运行后考虑实施

## 目录
1. [架构概述](#架构概述)
2. [权限模型设计](#权限模型设计)
3. [数据隔离策略](#数据隔离策略)
4. [跨平台实现方案](#跨平台实现方案)
5. [数据流控制架构](#数据流控制架构)
6. [实施路线图](#实施路线图)
7. [配置示例](#配置示例)
8. [性能优化](#性能优化)
9. [安全考量](#安全考量)

## 架构概述

### 业务需求
- 支持多租户（客户）数据完全隔离
- 组织内部多业务线灵活权限管理
- 环境分离（开发/测试/生产）
- 细粒度的角色权限控制
- 跨多个BI平台统一权限管理

### 核心设计原则
1. **最小权限原则**：用户仅能访问其职责范围内的数据
2. **分层隔离**：不同层级采用不同的隔离策略
3. **统一身份**：单点登录与统一权限管理
4. **可扩展性**：支持租户和业务快速增长
5. **审计追踪**：完整的权限变更和数据访问日志

## 权限模型设计

### 1. 多维度权限层次结构

根据业务最佳实践，采用灵活的多维度权限模型：

```
租户(Tenant) 
├── 组织(Organization)
│   ├── 业务域(Business Domain) 
│   │   ├── 项目(Project)
│   │   │   ├── 环境(Environment: dev/test/prod)
│   │   │   └── 团队(Team)
│   │   │       └── 用户(User) + 角色(Role)
│   │   └── 数据集(Dataset)
│   └── 权限策略(Policy)
└── 资源配额(Resource Quota)
```

### 2. 核心实体定义

#### 租户(Tenant)
```sql
CREATE TABLE tenants (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50) UNIQUE NOT NULL,
    status ENUM('active', 'suspended', 'deleted'),
    resource_quota JSON, -- CPU, 内存, 存储配额
    created_at TIMESTAMP,
    updated_at TIMESTAMP
);
```

#### 组织(Organization)
```sql
CREATE TABLE organizations (
    id BIGINT PRIMARY KEY,
    tenant_id BIGINT REFERENCES tenants(id),
    name VARCHAR(100) NOT NULL,
    parent_id BIGINT REFERENCES organizations(id), -- 支持组织层级
    settings JSON, -- 组织级配置
    created_at TIMESTAMP
);
```

#### 业务域(Business Domain)
```sql
CREATE TABLE business_domains (
    id BIGINT PRIMARY KEY,
    organization_id BIGINT REFERENCES organizations(id),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50) NOT NULL,
    description TEXT,
    data_retention_days INT DEFAULT 90,
    UNIQUE(organization_id, code)
);
```

#### 项目与环境
```sql
CREATE TABLE projects (
    id BIGINT PRIMARY KEY,
    business_domain_id BIGINT REFERENCES business_domains(id),
    name VARCHAR(100) NOT NULL,
    code VARCHAR(50) NOT NULL,
    UNIQUE(business_domain_id, code)
);

CREATE TABLE environments (
    id BIGINT PRIMARY KEY,
    project_id BIGINT REFERENCES projects(id),
    name VARCHAR(50) NOT NULL, -- dev, test, staging, prod
    is_production BOOLEAN DEFAULT false
);
```

#### 角色权限模型
```sql
CREATE TABLE roles (
    id BIGINT PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    scope ENUM('tenant', 'organization', 'domain', 'project', 'team'),
    permissions JSON, -- 具体权限列表
    is_system_role BOOLEAN DEFAULT false
);

CREATE TABLE user_role_assignments (
    id BIGINT PRIMARY KEY,
    user_id BIGINT NOT NULL,
    role_id BIGINT REFERENCES roles(id),
    scope_type ENUM('tenant', 'organization', 'domain', 'project', 'team'),
    scope_id BIGINT NOT NULL, -- 对应scope_type的具体ID
    granted_at TIMESTAMP,
    granted_by BIGINT
);
```

### 3. 权限策略引擎

#### 基于属性的访问控制(ABAC)
```json
{
  "policy": {
    "name": "nginx_logs_access",
    "version": "1.0",
    "rules": [
      {
        "effect": "allow",
        "subjects": ["role:data_analyst"],
        "resources": ["dataset:nginx_logs"],
        "conditions": {
          "environment": {"in": ["dev", "test"]},
          "time_range": {"max_days": 30},
          "data_sensitivity": {"level": "low"}
        }
      },
      {
        "effect": "allow", 
        "subjects": ["role:ops_engineer"],
        "resources": ["dataset:nginx_logs"],
        "conditions": {
          "environment": {"in": ["prod"]},
          "columns": {"exclude": ["user_id", "session_id"]}
        }
      }
    ]
  }
}
```

## 数据隔离策略

### 1. 租户级隔离 - 数据库分离
适用于：不同客户间的完全隔离

```yaml
tenant_isolation:
  strategy: "database_separation"
  pattern: "nginx_analytics_{tenant_code}"
  example: 
    - nginx_analytics_company_a
    - nginx_analytics_company_b
  advantages: 
    - 完全物理隔离
    - 独立备份恢复
    - 性能隔离
  disadvantages:
    - 资源利用率较低
    - 运维复杂度高
```

### 2. 组织级隔离 - 表前缀分离
适用于：大租户内部的业务线隔离

```sql
-- ClickHouse表结构示例
CREATE TABLE nginx_analytics.nginx_logs_finance (
    tenant_id String,
    organization_id String,
    business_domain String DEFAULT 'finance',
    timestamp DateTime,
    request_uri String,
    -- 其他字段...
) ENGINE = MergeTree()
PARTITION BY toYYYYMM(timestamp)
ORDER BY (tenant_id, organization_id, timestamp);

CREATE TABLE nginx_analytics.nginx_logs_marketing (
    tenant_id String,
    organization_id String, 
    business_domain String DEFAULT 'marketing',
    -- 相同结构...
);
```

### 3. 项目级隔离 - 行级安全(RLS)
适用于：同业务线不同项目的数据隔离

```sql
-- ClickHouse RLS实现示例
CREATE VIEW nginx_logs_secure AS
SELECT * FROM nginx_analytics.nginx_logs 
WHERE tenant_id = currentUser('tenant_id')
  AND organization_id = currentUser('org_id')
  AND (
    business_domain = currentUser('domain') 
    OR hasRole('cross_domain_reader')
  )
  AND (
    environment IN currentUser('allowed_envs')
    OR hasRole('production_access')
  );
```

### 4. 动态分区策略
结合时间和租户的混合分区：

```sql
-- 按租户+时间分区，优化查询性能
CREATE TABLE nginx_analytics.nginx_logs_partitioned (
    tenant_id String,
    organization_id String,
    project_id String,
    environment String,
    timestamp DateTime,
    -- 数据字段
) ENGINE = MergeTree()
PARTITION BY (tenant_id, toYYYYMM(timestamp))
ORDER BY (organization_id, project_id, timestamp);
```

## 跨平台实现方案

### 1. Grafana权限映射

#### Grafana组织架构映射
```yaml
grafana_mapping:
  tenant_company_a:
    org_id: 2
    folders:
      - name: "Finance_Dashboard"
        permissions:
          - role: "finance_analyst"
            permission: "view"
          - role: "finance_manager" 
            permission: "edit"
      - name: "Marketing_Dashboard"
        permissions:
          - role: "marketing_analyst"
            permission: "view"
```

#### 动态数据源配置
```python
# Grafana数据源动态配置
def create_datasource_config(user_context):
    return {
        "name": f"ClickHouse_{user_context.tenant_code}",
        "type": "clickhouse",
        "url": "http://clickhouse:8123",
        "database": f"nginx_analytics_{user_context.tenant_code}",
        "user": user_context.db_user,
        "basicAuth": True,
        "jsonData": {
            "defaultDatabase": f"nginx_analytics_{user_context.tenant_code}",
            "timeout": 30
        }
    }
```

### 2. DataEase权限集成

#### 数据集权限控制
```json
{
  "dataset_permission": {
    "dataset_id": "nginx_logs_001",
    "row_permissions": [
      {
        "field": "tenant_id",
        "operator": "eq",
        "value": "{{current_user.tenant_id}}"
      },
      {
        "field": "business_domain", 
        "operator": "in",
        "value": "{{current_user.allowed_domains}}"
      }
    ],
    "column_permissions": {
      "sensitive_fields": ["user_id", "session_id"],
      "allowed_roles": ["admin", "security_analyst"]
    }
  }
}
```

### 3. Superset安全集成

#### Row Level Security配置
```python
# Superset RLS过滤器
class TenantRowFilter(BaseFilter):
    def apply(self, query, value):
        user_context = get_current_user_context()
        conditions = [
            query.filter(Table.tenant_id == user_context.tenant_id)
        ]
        
        if not user_context.has_role('cross_domain_access'):
            conditions.append(
                query.filter(Table.business_domain.in_(user_context.allowed_domains))
            )
            
        return query.filter(and_(*conditions))
```

### 4. Nightingale监控权限

#### 告警规则权限隔离
```yaml
alert_rule_permissions:
  rule_groups:
    - name: "nginx_performance_alerts"
      tenant_filter: "tenant_id=\"{{tenant_code}}\""
      rules:
        - alert: "HighErrorRate"
          expr: |
            rate(nginx_requests_total{tenant_id="{{tenant_code}}", status=~"5.."}[5m]) > 0.1
          labels:
            tenant: "{{tenant_code}}"
            severity: "warning"
```

## 数据流控制架构

### 1. API网关层权限控制

```python
class TenantAwareAPIGateway:
    def authorize_request(self, request, user_context):
        # 1. 验证租户访问权限
        if not self.validate_tenant_access(user_context.tenant_id):
            raise UnauthorizedError("Invalid tenant access")
            
        # 2. 检查资源配额
        quota = self.get_tenant_quota(user_context.tenant_id)
        if self.check_quota_exceeded(quota, request):
            raise QuotaExceededError("Resource quota exceeded")
            
        # 3. 注入数据过滤条件
        request.add_filter('tenant_id', user_context.tenant_id)
        request.add_filter('allowed_domains', user_context.allowed_domains)
        
        return request
```

### 2. 数据查询层过滤

```python
class SecureQueryProcessor:
    def process_query(self, sql_query, user_context):
        # SQL注入防护
        sanitized_query = self.sanitize_sql(sql_query)
        
        # 动态添加权限过滤条件
        filtered_query = self.add_security_filters(
            sanitized_query, 
            user_context
        )
        
        # 执行查询并记录审计日志
        result = self.execute_with_audit(filtered_query, user_context)
        
        return result
    
    def add_security_filters(self, query, user_context):
        filters = [
            f"tenant_id = '{user_context.tenant_id}'",
        ]
        
        if not user_context.has_permission('cross_domain_access'):
            domains = "', '".join(user_context.allowed_domains)
            filters.append(f"business_domain IN ('{domains}')")
            
        if not user_context.has_permission('production_access'):
            filters.append("environment != 'prod'")
            
        where_clause = " AND ".join(filters)
        
        # 智能SQL过滤条件注入
        if "WHERE" in query.upper():
            query += f" AND {where_clause}"
        else:
            query += f" WHERE {where_clause}"
            
        return query
```

### 3. 缓存层权限隔离

```python
class TenantAwareCache:
    def get_cache_key(self, base_key, user_context):
        return f"{base_key}:tenant_{user_context.tenant_id}:domain_{user_context.primary_domain}"
    
    def get_with_permissions(self, key, user_context):
        cache_key = self.get_cache_key(key, user_context)
        cached_data = self.redis_client.get(cache_key)
        
        if cached_data:
            return self.apply_column_permissions(cached_data, user_context)
        
        return None
```

## 实施路线图

### 第一阶段：基础权限框架(4-6周)
1. **用户认证与授权系统**
   - 实现JWT token生成与验证
   - 建立用户、角色、权限基础表结构
   - 开发权限检查中间件

2. **租户隔离基础设施**
   - ClickHouse多租户数据库创建脚本
   - 基础的RLS查询过滤器
   - API网关权限拦截器

3. **审计日志系统**
   - 权限变更日志记录
   - 数据访问审计追踪

### 第二阶段：BI平台集成(6-8周)
1. **Grafana权限集成**
   - 动态组织和文件夹创建
   - 数据源权限配置
   - 仪表板访问控制

2. **DataEase权限对接**
   - 数据集行级权限过滤
   - 仪表板权限管理
   - 自定义权限API开发

3. **Superset安全集成**
   - RLS过滤器实现
   - 数据库权限映射
   - 自定义安全管理器

### 第三阶段：高级功能与优化(4-6周)
1. **动态权限策略**
   - 基于属性的访问控制(ABAC)
   - 权限策略热更新
   - 复杂权限规则引擎

2. **性能优化**
   - 查询缓存权限隔离
   - 分区策略优化
   - 索引权限优化

3. **监控与运维**
   - 权限性能监控
   - 异常权限访问告警
   - 权限健康检查

### 第四阶段：企业级扩展(ongoing)
1. **多云部署支持**
2. **高可用权限服务**  
3. **权限数据备份与恢复**

## 配置示例

### 1. ClickHouse多租户配置

```xml
<!-- clickhouse用户配置 -->
<clickhouse>
    <users>
        <tenant_company_a>
            <password_sha256_hex>...</password_sha256_hex>
            <networks>
                <ip>::/0</ip>
            </networks>
            <profile>tenant_profile</profile>
            <quota>tenant_quota</quota>
            <databases>
                <nginx_analytics_company_a>1</nginx_analytics_company_a>
            </databases>
            <access_management>1</access_management>
        </tenant_company_a>
    </users>
    
    <profiles>
        <tenant_profile>
            <max_memory_usage>10000000000</max_memory_usage>
            <max_query_size>1000000000</max_query_size>
            <max_execution_time>300</max_execution_time>
        </tenant_profile>
    </profiles>
    
    <quotas>
        <tenant_quota>
            <interval>
                <duration>3600</duration>
                <queries>10000</queries>
                <query_selects>5000</query_selects>
                <result_rows>100000000</result_rows>
            </interval>
        </tenant_quota>
    </quotas>
</clickhouse>
```

### 2. Nginx反向代理权限路由

```nginx
# nginx配置：基于子域名的租户路由
map $host $tenant_code {
    ~^(?<tenant>\w+)\.analytics\.company\.com$ $tenant;
    default "default";
}

upstream backend_$tenant_code {
    server backend1:8080;
    server backend2:8080;
}

server {
    listen 80;
    server_name ~^(?<tenant>\w+)\.analytics\.company\.com$;
    
    # 添加租户标识头
    proxy_set_header X-Tenant-Code $tenant;
    
    location / {
        proxy_pass http://backend_$tenant_code;
        
        # 权限检查
        auth_request /auth;
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
    
    location = /auth {
        internal;
        proxy_pass http://auth-service/validate;
        proxy_set_header X-Tenant-Code $tenant;
        proxy_pass_request_body off;
        proxy_set_header Content-Length "";
    }
}
```

### 3. 权限中间件配置

```python
# Django中间件示例
class TenantPermissionMiddleware:
    def __init__(self, get_response):
        self.get_response = get_response
        
    def __call__(self, request):
        # 从请求中提取租户信息
        tenant_code = self.extract_tenant_code(request)
        
        if tenant_code:
            # 验证租户权限
            user_context = self.build_user_context(request.user, tenant_code)
            
            # 注入到请求上下文
            request.tenant_context = user_context
            
            # 设置数据库路由
            request.db_alias = f'nginx_analytics_{tenant_code}'
        
        response = self.get_response(request)
        return response
```

## 性能优化

### 1. 查询性能优化策略

```sql
-- 租户感知的索引策略
CREATE INDEX idx_tenant_time ON nginx_analytics.nginx_logs 
(tenant_id, timestamp, business_domain) 
TYPE minmax GRANULARITY 8192;

-- 物化视图预计算热点数据
CREATE MATERIALIZED VIEW nginx_hourly_stats
ENGINE = SummingMergeTree()
PARTITION BY (tenant_id, toYYYYMM(hour))
ORDER BY (tenant_id, business_domain, hour)
AS SELECT
    tenant_id,
    business_domain,
    toStartOfHour(timestamp) as hour,
    count() as request_count,
    avg(response_time) as avg_response_time,
    countIf(status_code >= 400) as error_count
FROM nginx_analytics.nginx_logs
GROUP BY tenant_id, business_domain, hour;
```

### 2. 缓存层优化

```python
class PerformanceOptimizedCache:
    def __init__(self):
        self.redis_client = RedisCluster(startup_nodes=redis_nodes)
        self.local_cache = TTLCache(maxsize=10000, ttl=300)  # 5分钟本地缓存
    
    def get_dashboard_data(self, dashboard_id, user_context, params):
        # L1缓存：进程内缓存
        cache_key = f"dashboard_{dashboard_id}_{hash(str(params))}"
        local_result = self.local_cache.get(cache_key)
        if local_result:
            return self.apply_user_permissions(local_result, user_context)
            
        # L2缓存：Redis集群
        tenant_cache_key = f"tenant_{user_context.tenant_id}:{cache_key}"
        redis_result = self.redis_client.get(tenant_cache_key)
        if redis_result:
            parsed_result = json.loads(redis_result)
            self.local_cache[cache_key] = parsed_result
            return self.apply_user_permissions(parsed_result, user_context)
            
        # 缓存未命中，查询数据库
        db_result = self.query_database_with_permissions(dashboard_id, user_context, params)
        
        # 写入缓存（异步）
        self.async_cache_write(cache_key, tenant_cache_key, db_result)
        
        return db_result
```

### 3. 分布式权限检查优化

```python
class DistributedPermissionChecker:
    def __init__(self):
        self.permission_cache = {}
        self.batch_size = 100
        
    async def batch_check_permissions(self, permission_requests):
        """批量权限检查，减少网络往返"""
        uncached_requests = []
        results = {}
        
        # 检查本地缓存
        for req in permission_requests:
            cache_key = self.get_permission_cache_key(req)
            if cache_key in self.permission_cache:
                results[req.id] = self.permission_cache[cache_key]
            else:
                uncached_requests.append(req)
        
        # 批量查询未缓存的权限
        if uncached_requests:
            batch_results = await self.query_permissions_batch(uncached_requests)
            for req, result in zip(uncached_requests, batch_results):
                cache_key = self.get_permission_cache_key(req)
                self.permission_cache[cache_key] = result
                results[req.id] = result
                
        return results
```

## 安全考量

### 1. 数据泄露防护

```python
class DataLeakageProtection:
    def __init__(self):
        self.sensitive_patterns = [
            r'\b\d{15,19}\b',  # 信用卡号
            r'\b\d{3}-\d{2}-\d{4}\b',  # 身份证号
            r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'  # 邮箱
        ]
        
    def scan_and_mask_data(self, data, user_context):
        """扫描并脱敏敏感数据"""
        if not user_context.has_permission('view_sensitive_data'):
            for pattern in self.sensitive_patterns:
                data = re.sub(pattern, '***MASKED***', str(data))
        return data
        
    def audit_data_access(self, user_id, tenant_id, resource, action):
        """记录数据访问审计"""
        audit_log = {
            'timestamp': datetime.utcnow(),
            'user_id': user_id,
            'tenant_id': tenant_id,
            'resource': resource,
            'action': action,
            'ip_address': request.remote_addr,
            'user_agent': request.user_agent.string
        }
        self.audit_logger.info(json.dumps(audit_log))
```

### 2. SQL注入防护

```python
class SQLInjectionProtection:
    def __init__(self):
        self.dangerous_patterns = [
            r'(\bunion\b.*\bselect\b)',
            r'(\bdrop\b.*\btable\b)',
            r'(\bdelete\b.*\bfrom\b)',
            r'(\binsert\b.*\binto\b)',
            r'(\bupdate\b.*\bset\b)'
        ]
        
    def validate_query(self, query):
        """验证查询安全性"""
        query_lower = query.lower()
        
        for pattern in self.dangerous_patterns:
            if re.search(pattern, query_lower, re.IGNORECASE):
                raise SecurityError(f"Potentially dangerous SQL pattern detected: {pattern}")
                
        # 白名单验证：只允许SELECT查询
        if not query_lower.strip().startswith('select'):
            raise SecurityError("Only SELECT queries are allowed")
            
        return True
```

### 3. 权限提升防护

```python
class PrivilegeEscalationProtection:
    def validate_permission_assignment(self, assigner_user, target_user, new_role):
        """防止权限提升攻击"""
        
        # 检查分配者是否有权限分配该角色
        if not self.can_assign_role(assigner_user, new_role):
            raise PermissionError("Insufficient privileges to assign this role")
            
        # 检查是否尝试分配更高级别的权限
        if self.get_role_level(new_role) > self.get_user_max_role_level(assigner_user):
            raise PermissionError("Cannot assign role with higher privilege level")
            
        # 检查租户边界
        if target_user.tenant_id != assigner_user.tenant_id and not assigner_user.is_super_admin():
            raise PermissionError("Cannot assign roles across tenant boundaries")
            
        return True
```

## 总结

本架构设计文档提供了一套完整的多租户权限控制解决方案，具备以下特点：

1. **灵活的权限层次**：支持从租户到用户的多级权限管理
2. **全面的数据隔离**：从数据库层到应用层的完整隔离策略
3. **跨平台兼容性**：统一的权限模型适配多个BI平台
4. **高性能设计**：缓存优化和批量处理减少性能开销
5. **安全加固**：多层安全防护机制和审计追踪
6. **可扩展架构**：支持租户和业务快速增长的弹性设计

通过遵循本文档的设计原则和实施指导，可以构建一个安全、高效、可扩展的企业级多租户数据分析平台。

---
*文档版本：v1.0*  
*创建时间：2025-01-11*  
*适用范围：nginx日志分析多租户权限控制架构*